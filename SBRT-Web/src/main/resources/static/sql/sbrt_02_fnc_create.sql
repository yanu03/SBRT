
DELIMITER $$
CREATE OR REPLACE FUNCTION `sbrt`.`FN_GET_CUR_ALLOC_NO`(`param_rout_id` VARCHAR(10),
	`param_vhc_id` VARCHAR(10),
	`param_date` DATE
) RETURNS int(11)
    COMMENT '배차번호 찾기'
BEGIN
	DECLARE var_rep_rout_id VARCHAR(10);
	DECLARE var_alloc_no INTEGER;
	DECLARE var_way_div VARCHAR(5);
	
	
	SELECT REP_ROUT_ID, WAY_DIV
		INTO var_rep_rout_id, var_way_div
	FROM BMS_ROUT_MST
	WHERE ROUT_ID = param_rout_id;
	
		
	SELECT ALLOC_NO
		INTO var_alloc_no
	FROM BRT_DAY_ALLOC_PL_INFO
	WHERE OPER_DT = param_date
		AND REP_ROUT_ID = var_rep_rout_id
		AND WAY_DIV = var_way_div
		AND VHC_ID = param_vhc_id;	
	
	RETURN var_alloc_no;
END $$
DELIMITER ;;

DELIMITER $$
CREATE OR REPLACE FUNCTION `sbrt`.`FN_GET_CUR_PHASE_NO`(`PARAM_CRS_ID` VARCHAR(10),
	`PARAM_DATE_TIME` DATETIME
) RETURNS int(11)
    COMMENT '교차로의 초록불 현시 번호 가져오기'
BEGIN
	DECLARE VAR_PHASE_NO_A INT;
	DECLARE VAR_PHASE_NO_B INT;
	DECLARE RT_PHASE_NO INT;
	
	DECLARE VAR_BASE_PLAN_NO INT DEFAULT(0);
	DECLARE VAR_DAY_PLAN_NO INT DEFAULT(0);
	DECLARE VAR_TM_PLAN_NO INT DEFAULT(0);
	DECLARE VAR_WEEK_DAY_NO INT DEFAULT(0);
	
	DECLARE VAR_DAY_PLAN_ST_TM TIME;
	DECLARE VAR_DAY_PLAN_OFFSET INT;
	DECLARE VAR_DAY_PLAN_PERIOD_LEN INT;	
	DECLARE VAR_DAY_PLAN_A1_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A2_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A3_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A4_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A5_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A6_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A7_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A8_PL_VAL INT;
	
	DECLARE VAR_DAY_PLAN_B1_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B2_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B3_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B4_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B5_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B6_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B7_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B8_PL_VAL INT;	
	DECLARE VAR_DAY_PLAN_PHASE_CNT INT;	
	

	DECLARE VAR_START_PERIOD_TM TIME;
	DECLARE VAR_END_PERIOD_TM TIME;
	
	DECLARE VAR_START_TM TIME;
	DECLARE VAR_END_TM TIME;

	DECLARE VAR_LOOP_CNT INT;	
	DECLARE VAR_LOOP_IDX INT;
	
	
	SET VAR_PHASE_NO_A = 0;
	SET VAR_PHASE_NO_B = 0;
	SET VAR_DAY_PLAN_NO = 0;
	
	
	
	
	-- 특수일(휴일) 정보에서 일일계획번호 조회
	SELECT DAY_PL_NO INTO VAR_DAY_PLAN_NO
	FROM BMS_CRS_SIGOPER_HOLIDAY_PLAN_INFO
	WHERE CRS_ID = PARAM_CRS_ID
	AND APPL_MON = DATE_FORMAT(PARAM_DATE_TIME, '%m') AND APPL_DT = DATE_FORMAT(PARAM_DATE_TIME, '%d');	
	
		
	-- 특수일이 아니라면 주간 정보에서 일일계획번호 조회
	IF(VAR_DAY_PLAN_NO = 0) THEN
		SELECT DAYOFWEEK(PARAM_DATE_TIME) INTO VAR_WEEK_DAY_NO; 	-- 요일 확인
		
		IF(VAR_WEEK_DAY_NO = 1) THEN 			-- 일
			SELECT DAY_PL_NO_0 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 2) THEN		-- 월
			SELECT DAY_PL_NO_1 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 3) THEN		-- 화
			SELECT DAY_PL_NO_2 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID; 
		ELSEIF (VAR_WEEK_DAY_NO = 4) THEN		-- 수
			SELECT DAY_PL_NO_3 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 5) THEN		-- 목
			SELECT DAY_PL_NO_4 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 6) THEN		-- 금
			SELECT DAY_PL_NO_5 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSE		-- 토
			SELECT DAY_PL_NO_6 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		END IF;
			
	END IF;
	
	
	-- BASE신호계획정보 가져오기
	SELECT
		A.BASE_PL_NO
		,A.TM_PL_NO
		,A.ST_TM
		,A.PERIOD_LEN
		,A.OFFSET
		,A.A1_PL_VAL ,A.A2_PL_VAL ,A.A3_PL_VAL ,A.A4_PL_VAL ,A.A5_PL_VAL ,A.A6_PL_VAL ,A.A7_PL_VAL ,A.A8_PL_VAL
		,A.B1_PL_VAL ,A.B2_PL_VAL ,A.B3_PL_VAL ,A.B4_PL_VAL ,A.B5_PL_VAL ,A.B6_PL_VAL ,A.B7_PL_VAL ,A.B8_PL_VAL
		,B.PHASE_CNT
		INTO VAR_BASE_PLAN_NO, VAR_TM_PLAN_NO, VAR_DAY_PLAN_ST_TM, VAR_DAY_PLAN_PERIOD_LEN, VAR_DAY_PLAN_OFFSET
				,VAR_DAY_PLAN_A1_PL_VAL ,VAR_DAY_PLAN_A2_PL_VAL ,VAR_DAY_PLAN_A3_PL_VAL ,VAR_DAY_PLAN_A4_PL_VAL
				,VAR_DAY_PLAN_A5_PL_VAL ,VAR_DAY_PLAN_A6_PL_VAL ,VAR_DAY_PLAN_A7_PL_VAL ,VAR_DAY_PLAN_A8_PL_VAL
				,VAR_DAY_PLAN_B1_PL_VAL ,VAR_DAY_PLAN_B2_PL_VAL ,VAR_DAY_PLAN_B3_PL_VAL ,VAR_DAY_PLAN_B4_PL_VAL
				,VAR_DAY_PLAN_B5_PL_VAL ,VAR_DAY_PLAN_B6_PL_VAL ,VAR_DAY_PLAN_B7_PL_VAL ,VAR_DAY_PLAN_B8_PL_VAL						
				,VAR_DAY_PLAN_PHASE_CNT
	FROM BMS_CRS_SIGOPER_BASE_PLAN_INFO A
		LEFT JOIN BMS_CRS_MST B ON B.CRS_ID = A.CRS_ID
	WHERE A.CRS_ID = PARAM_CRS_ID
	AND A.BASE_PL_NO = VAR_DAY_PLAN_NO
	-- AND A.ST_TM < TIME_FORMAT(PARAM_DATE_TIME, '%H:%i')
	AND DATE_ADD(A.ST_TM, INTERVAL A.OFFSET SECOND) <= TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S')	
	
	ORDER BY A.ST_HOUR DESC
	LIMIT 1;
	
	
	
	-- BASE 신호시간계획이 없는 경우 일일신호계획에서 가져오기
	IF(VAR_BASE_PLAN_NO = 0) THEN			
		-- 일일신호계획정보 가져오기
		SELECT
			A.TM_PL_NO
			,A.ST_TM
			,A.PERIOD_LEN
			,A.OFFSET
			,A.A1_PL_VAL ,A.A2_PL_VAL ,A.A3_PL_VAL ,A.A4_PL_VAL ,A.A5_PL_VAL ,A.A6_PL_VAL ,A.A7_PL_VAL ,A.A8_PL_VAL
			,A.B1_PL_VAL ,A.B2_PL_VAL ,A.B3_PL_VAL ,A.B4_PL_VAL ,A.B5_PL_VAL ,A.B6_PL_VAL ,A.B7_PL_VAL ,A.B8_PL_VAL
			,B.PHASE_CNT
			INTO VAR_TM_PLAN_NO, VAR_DAY_PLAN_ST_TM, VAR_DAY_PLAN_PERIOD_LEN, VAR_DAY_PLAN_OFFSET
					,VAR_DAY_PLAN_A1_PL_VAL ,VAR_DAY_PLAN_A2_PL_VAL ,VAR_DAY_PLAN_A3_PL_VAL ,VAR_DAY_PLAN_A4_PL_VAL
					,VAR_DAY_PLAN_A5_PL_VAL ,VAR_DAY_PLAN_A6_PL_VAL ,VAR_DAY_PLAN_A7_PL_VAL ,VAR_DAY_PLAN_A8_PL_VAL
					,VAR_DAY_PLAN_B1_PL_VAL ,VAR_DAY_PLAN_B2_PL_VAL ,VAR_DAY_PLAN_B3_PL_VAL ,VAR_DAY_PLAN_B4_PL_VAL
					,VAR_DAY_PLAN_B5_PL_VAL ,VAR_DAY_PLAN_B6_PL_VAL ,VAR_DAY_PLAN_B7_PL_VAL ,VAR_DAY_PLAN_B8_PL_VAL						
					,VAR_DAY_PLAN_PHASE_CNT
		FROM BMS_CRS_SIGOPER_DAY_PLAN_INFO A
			LEFT JOIN BMS_CRS_MST B ON B.CRS_ID = A.CRS_ID
		WHERE A.CRS_ID = PARAM_CRS_ID
		AND A.DAY_PL_NO = VAR_DAY_PLAN_NO
		-- AND A.ST_TM < TIME_FORMAT(PARAM_DATE_TIME, '%H:%i')
		AND DATE_ADD(A.ST_TM, INTERVAL A.OFFSET SECOND) <= TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S')	
		
		ORDER BY A.ST_HOUR DESC
		LIMIT 1;
	END IF;
	
	
	-- 특정 시간에 초록불 현시번호 찾기
	SET VAR_START_PERIOD_TM = DATE_ADD(VAR_DAY_PLAN_ST_TM, INTERVAL VAR_DAY_PLAN_OFFSET SECOND);
	
	SET VAR_LOOP_CNT = 0;
	loop_day_plan:LOOP
		
		SET VAR_END_PERIOD_TM = DATE_ADD(VAR_START_PERIOD_TM, INTERVAL VAR_DAY_PLAN_PERIOD_LEN SECOND);
		

		-- 찾고자 하는 시간이 각 주기별 계획시간에 포함되는지 확인				
		 IF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_START_PERIOD_TM, '%H:%i:%S') && TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') < TIME_FORMAT(VAR_END_PERIOD_TM, '%H:%i:%S')) THEN					
			

			SET VAR_START_TM = VAR_START_PERIOD_TM;			
			SET VAR_END_TM = DATE_ADD(VAR_START_PERIOD_TM, INTERVAL VAR_DAY_PLAN_A1_PL_VAL SECOND);
			
						
			-- RING A
			SET VAR_LOOP_IDX = 1;
			WHILE(VAR_LOOP_IDX <= VAR_DAY_PLAN_PHASE_CNT) DO
			
				IF(VAR_LOOP_IDX = 1) THEN
					SET VAR_START_TM = VAR_START_PERIOD_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A1_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 2) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A2_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 3) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A3_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 4) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A4_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 5) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A5_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 6) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A6_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 7) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A7_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 8) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A8_PL_VAL SECOND);	
				END IF;							
				
				-- 찾고자 하는 시간이 각 현시별 계획시간에 포함되는지 확인
				IF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_START_TM, '%H:%i:%S') && TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') < TIME_FORMAT(VAR_END_TM, '%H:%i:%S')) THEN			
					SET VAR_PHASE_NO_A = VAR_LOOP_IDX;
					SET VAR_LOOP_IDX = VAR_DAY_PLAN_PHASE_CNT;
				ELSE
					SET VAR_LOOP_IDX = VAR_LOOP_IDX+1;
				END IF;													

			END WHILE;
			
			
			-- RING B
			SET VAR_LOOP_IDX = 1;
			WHILE(VAR_LOOP_IDX <= VAR_DAY_PLAN_PHASE_CNT) DO
			
				IF(VAR_LOOP_IDX = 1) THEN
					SET VAR_START_TM = VAR_START_PERIOD_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B1_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 2) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B2_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 3) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B3_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 4) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B4_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 5) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B5_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 6) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B6_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 7) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B7_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 8) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B8_PL_VAL SECOND);	
				END IF;							
				
				-- 찾고자 하는 시간이 각 현시별 계획시간에 포함되는지 확인				
				IF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_START_TM, '%H:%i:%S') && TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') < TIME_FORMAT(VAR_END_TM, '%H:%i:%S')) THEN			
					SET VAR_PHASE_NO_B = VAR_LOOP_IDX;
					SET VAR_LOOP_IDX = VAR_DAY_PLAN_PHASE_CNT;
				ELSE
					SET VAR_LOOP_IDX = VAR_LOOP_IDX+1;
				END IF;													


			END WHILE;			
			
			
			LEAVE loop_day_plan;
			
		END IF;
	
	
		SET VAR_START_PERIOD_TM = VAR_END_PERIOD_TM;
		
		SET VAR_LOOP_CNT = VAR_LOOP_CNT+1;
				
		IF(VAR_LOOP_CNT >= 5000) THEN  -- 무한루프방어코드				
			LEAVE loop_day_plan;
		END IF;		
		
	
	END LOOP;
	
	
	
	IF(VAR_PHASE_NO_A <= VAR_PHASE_NO_B) THEN
		SET RT_PHASE_NO = VAR_PHASE_NO_A;
	ELSE
		SET RT_PHASE_NO = VAR_PHASE_NO_B;
	END IF;
	
	


	RETURN RT_PHASE_NO;
--	RETURN VAR_DAY_PLAN_NO;
END $$
DELIMITER ;;

DELIMITER $$
CREATE OR REPLACE FUNCTION `sbrt`.`FN_GET_DAY_DIV`(`param_date` DATE
) RETURNS char(5) CHARSET utf8
    COMMENT '요일구분코드 가져오기'
BEGIN

	DECLARE var_week_day_no INTEGER;
	DECLARE var_is_holiday INTEGER;
	DECLARE var_day_div VARCHAR(5);
	
		
	SELECT DAYOFWEEK(param_date) INTO var_week_day_no;
	
	SELECT COUNT(HOLI_DT)
		INTO var_is_holiday
	FROM BRT_HOLI_MST
	WHERE HOLI_DT = param_date;
	
	IF(var_is_holiday > 0 OR var_week_day_no = 1 OR var_week_day_no = 7) THEN -- 휴일여부 확인 (1:일요일, 7:토요일)
		SET var_day_div = 'DY002';
	ELSE
		SET var_day_div = 'DY001';
	END IF;	


	RETURN var_day_div;

END $$
DELIMITER ;;

DELIMITER $$
CREATE OR REPLACE FUNCTION `sbrt`.`FN_GET_OPER_SN`(`param_rout_id` VARCHAR(10),
	`param_node_id` VARCHAR(10),
	`param_vhc_id` VARCHAR(10),
	`param_cur_tm` DATETIME
) RETURNS int(11)
    COMMENT '운행순번 찾기'
BEGIN
	DECLARE var_ret_oper_sn INT;
	DECLARE var_oper_sn INT;
	DECLARE var_alloc_no INT;
	DECLARE var_target_alloc_no INT;
	DECLARE var_arrv_tm TIME;	
	DECLARE var_dprt_tm TIME;
	DECLARE var_diff_sec INT DEFAULT(0);
	DECLARE var_min_diff_sec INT DEFAULT(-1);
	
	DECLARE var_oper_dt DATE;
	DECLARE var_cur_tm_str VARCHAR(8);
	DECLARE var_cur_hour_str VARCHAR(2);

	DECLARE var_no_more_rows INT DEFAULT(0);
		
	DECLARE var_cursor CURSOR FOR	     	
	SELECT 	
		OPER_SN
		,ALLOC_NO
		,TIME_FORMAT(DPRT_TM, '%H:%i:%S')
		,TIME_FORMAT(ARRV_TM, '%H:%i:%S')
	FROM BRT_CUR_OPER_ALLOC_PL_NODE_INFO 
	WHERE ROUT_ID = param_rout_id
		AND NODE_ID = param_node_id
		ORDER BY OPER_SN ASC;
       
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET var_no_more_rows = true;	
	
			
	SELECT TIME_FORMAT(param_cur_tm, '%H') INTO var_cur_hour_str;						
	SELECT CURDATE() INTO var_oper_dt;			
			

	-- CALL PROC_TMP_DBG(param_cur_tm);	
			
	IF(var_cur_hour_str >= 0 AND var_cur_hour_str <= 2 ) THEN 
		SET var_cur_hour_str = (var_cur_hour_str + 24); -- 시간비교를 위해 24시, 25시..로 변경
		SELECT DATE_ADD(param_cur_tm, INTERVAL -1 DAY) INTO var_oper_dt; -- 24시~02시까지는 전날 운행계획으로 설정
		
		-- CALL PROC_TMP_DBG(CONCAT(param_cur_tm, ',', DATE_ADD(param_cur_tm, INTERVAL -1 DAY), ',', var_oper_dt));	
		
	END IF;
	

		
	
	
	-- SELECT FN_GET_CUR_ALLOC_NO(param_rout_id, param_vhc_id, CURDATE()) INTO var_target_alloc_no;
	SELECT FN_GET_CUR_ALLOC_NO(param_rout_id, param_vhc_id, var_oper_dt) INTO var_target_alloc_no;	
	
	SELECT REPLACE(TIME_FORMAT(param_cur_tm, 'HOUR:%i:%S'), 'HOUR', var_cur_hour_str) INTO var_cur_tm_str;	
	

	OPEN var_cursor;
	var_loop: LOOP	
	
		FETCH var_cursor 
			INTO var_oper_sn
	        ,var_alloc_no
	        ,var_dprt_tm
            ,var_arrv_tm;
    
		IF var_no_more_rows THEN							        
			LEAVE var_loop;
		END IF;
		
		
		IF(var_alloc_no = var_target_alloc_no) THEN														
		
			SET var_diff_sec = TIME_TO_SEC(TIMEDIFF(TIME_FORMAT(param_cur_tm, '%H:%i:%S'), var_dprt_tm)); 			
			
			IF(var_min_diff_sec < 0) THEN -- 처음
				SET var_min_diff_sec = ABS(var_diff_sec);
				SET var_ret_oper_sn = var_oper_sn;			
			ELSEIF(ABS(var_diff_sec) < var_min_diff_sec) THEN
				SET var_min_diff_sec = ABS(var_diff_sec);
				SET var_ret_oper_sn = var_oper_sn;
			END IF;								
		
		END IF;		
		

      
	END LOOP var_loop;    
    
	CLOSE var_cursor;



	RETURN var_ret_oper_sn;
END $$
DELIMITER ;;

DELIMITER $$
CREATE OR REPLACE FUNCTION `sbrt`.`FN_GET_PHASE_REMAIN_TM`(`PARAM_CRS_ID` VARCHAR(10),
	`PARAM_DATE_TIME` VARCHAR(20),
	`PARAM_PHASE_NUM` INT,
	`PARAM_DAY_DIV` INT
) RETURNS int(11)
    COMMENT '교차로의 특정 현시의 초록불이 진행된 시간(+초) or 특정 현시가 초록불이 될 때까지 남은 시간(-초)'
BEGIN
	DECLARE VAR_PHASE_NO_A INT;
	DECLARE VAR_PHASE_NO_B INT;
	DECLARE RT_PHASE_NO INT;
	
	DECLARE VAR_DIFF_SEC_A INT DEFAULT(0);
	DECLARE VAR_DIFF_SEC_B INT DEFAULT(0);
	DECLARE RT_REMAIN_SEC INT DEFAULT(0);
	
	DECLARE VAR_BASE_PLAN_NO INT DEFAULT(0);
	DECLARE VAR_DAY_PLAN_NO INT DEFAULT(0);
	DECLARE VAR_TM_PLAN_NO INT DEFAULT(0);
	DECLARE VAR_WEEK_DAY_NO INT DEFAULT(0);
	
	DECLARE VAR_DAY_PLAN_ST_TM TIME;
	DECLARE VAR_DAY_PLAN_OFFSET INT;
	DECLARE VAR_DAY_PLAN_PERIOD_LEN INT;	
	DECLARE VAR_DAY_PLAN_A1_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A2_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A3_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A4_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A5_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A6_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A7_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_A8_PL_VAL INT;
	
	DECLARE VAR_DAY_PLAN_B1_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B2_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B3_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B4_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B5_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B6_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B7_PL_VAL INT;
	DECLARE VAR_DAY_PLAN_B8_PL_VAL INT;	
	DECLARE VAR_DAY_PLAN_PHASE_CNT INT;	
	

	DECLARE VAR_START_PERIOD_TM TIME;
	DECLARE VAR_END_PERIOD_TM TIME;
	
	DECLARE VAR_START_TM TIME;
	DECLARE VAR_END_TM TIME;

	DECLARE VAR_LOOP_CNT INT;	
	DECLARE VAR_LOOP_IDX INT;
	
	
	SET VAR_PHASE_NO_A = 0;
	SET VAR_PHASE_NO_B = 0;
	SET VAR_DAY_PLAN_NO = 0;
	
	-- PARAM_DAY_DIV - 0:없음, 1~7(일~토요일)
	
	
	-- 특수일(휴일) 정보에서 일일계획번호 조회
	IF(PARAM_DAY_DIV = 0) THEN
		SELECT DAY_PL_NO INTO VAR_DAY_PLAN_NO
		FROM BMS_CRS_SIGOPER_HOLIDAY_PLAN_INFO
		WHERE CRS_ID = PARAM_CRS_ID
		AND APPL_MON = DATE_FORMAT(PARAM_DATE_TIME, '%m') AND APPL_DT = DATE_FORMAT(PARAM_DATE_TIME, '%d');	
	END IF;
	
		
	-- 특수일이 아니라면 주간 정보에서 일일계획번호 조회
	IF(VAR_DAY_PLAN_NO = 0 OR (PARAM_DAY_DIV > 0)) THEN		
		
		if(PARAM_DAY_DIV > 0) THEN -- 특정 날짜가 아닌 평일,휴일에 대한 
			SET VAR_WEEK_DAY_NO = PARAM_DAY_DIV;
		ELSE 
			SELECT DAYOFWEEK(PARAM_DATE_TIME) INTO VAR_WEEK_DAY_NO; 	-- 요일 확인
		END IF;
		
		IF(VAR_WEEK_DAY_NO = 1) THEN 			-- 일
			SELECT DAY_PL_NO_0 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 2) THEN		-- 월
			SELECT DAY_PL_NO_1 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 3) THEN		-- 화
			SELECT DAY_PL_NO_2 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID; 
		ELSEIF (VAR_WEEK_DAY_NO = 4) THEN		-- 수
			SELECT DAY_PL_NO_3 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 5) THEN		-- 목
			SELECT DAY_PL_NO_4 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSEIF (VAR_WEEK_DAY_NO = 6) THEN		-- 금
			SELECT DAY_PL_NO_5 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		ELSE		-- 토
			SELECT DAY_PL_NO_6 INTO VAR_DAY_PLAN_NO FROM BMS_CRS_SIGOPER_WEEK_PLAN_INFO WHERE CRS_ID = PARAM_CRS_ID;
		END IF;
			
	END IF;
	
	
	
	-- BASE신호계획정보 가져오기
	SELECT
		A.BASE_PL_NO
		,A.TM_PL_NO
		,A.ST_TM
		,A.PERIOD_LEN
		,A.OFFSET
		,A.A1_PL_VAL ,A.A2_PL_VAL ,A.A3_PL_VAL ,A.A4_PL_VAL ,A.A5_PL_VAL ,A.A6_PL_VAL ,A.A7_PL_VAL ,A.A8_PL_VAL
		,A.B1_PL_VAL ,A.B2_PL_VAL ,A.B3_PL_VAL ,A.B4_PL_VAL ,A.B5_PL_VAL ,A.B6_PL_VAL ,A.B7_PL_VAL ,A.B8_PL_VAL
		,B.PHASE_CNT
		INTO VAR_BASE_PLAN_NO, VAR_TM_PLAN_NO, VAR_DAY_PLAN_ST_TM, VAR_DAY_PLAN_PERIOD_LEN, VAR_DAY_PLAN_OFFSET
				,VAR_DAY_PLAN_A1_PL_VAL ,VAR_DAY_PLAN_A2_PL_VAL ,VAR_DAY_PLAN_A3_PL_VAL ,VAR_DAY_PLAN_A4_PL_VAL
				,VAR_DAY_PLAN_A5_PL_VAL ,VAR_DAY_PLAN_A6_PL_VAL ,VAR_DAY_PLAN_A7_PL_VAL ,VAR_DAY_PLAN_A8_PL_VAL
				,VAR_DAY_PLAN_B1_PL_VAL ,VAR_DAY_PLAN_B2_PL_VAL ,VAR_DAY_PLAN_B3_PL_VAL ,VAR_DAY_PLAN_B4_PL_VAL
				,VAR_DAY_PLAN_B5_PL_VAL ,VAR_DAY_PLAN_B6_PL_VAL ,VAR_DAY_PLAN_B7_PL_VAL ,VAR_DAY_PLAN_B8_PL_VAL						
				,VAR_DAY_PLAN_PHASE_CNT
	FROM BMS_CRS_SIGOPER_BASE_PLAN_INFO A
		LEFT JOIN BMS_CRS_MST B ON B.CRS_ID = A.CRS_ID
	WHERE A.CRS_ID = PARAM_CRS_ID
	AND A.BASE_PL_NO = VAR_DAY_PLAN_NO
	-- AND A.ST_TM < TIME_FORMAT(PARAM_DATE_TIME, '%H:%i')
	AND DATE_ADD(A.ST_TM, INTERVAL A.OFFSET SECOND) <= TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S')	
	
	ORDER BY A.ST_HOUR DESC
	LIMIT 1;	
	
	
	-- BASE 신호시간계획이 없는 경우 일일신호계획에서 가져오기
	IF(VAR_BASE_PLAN_NO = 0) THEN	
		-- 일일신호계획정보 가져오기
		SELECT
			A.TM_PL_NO
			,A.ST_TM
			,A.PERIOD_LEN
			,A.OFFSET
			,A.A1_PL_VAL ,A.A2_PL_VAL ,A.A3_PL_VAL ,A.A4_PL_VAL ,A.A5_PL_VAL ,A.A6_PL_VAL ,A.A7_PL_VAL ,A.A8_PL_VAL
			,A.B1_PL_VAL ,A.B2_PL_VAL ,A.B3_PL_VAL ,A.B4_PL_VAL ,A.B5_PL_VAL ,A.B6_PL_VAL ,A.B7_PL_VAL ,A.B8_PL_VAL
			,B.PHASE_CNT
			INTO VAR_TM_PLAN_NO, VAR_DAY_PLAN_ST_TM, VAR_DAY_PLAN_PERIOD_LEN, VAR_DAY_PLAN_OFFSET
					,VAR_DAY_PLAN_A1_PL_VAL ,VAR_DAY_PLAN_A2_PL_VAL ,VAR_DAY_PLAN_A3_PL_VAL ,VAR_DAY_PLAN_A4_PL_VAL
					,VAR_DAY_PLAN_A5_PL_VAL ,VAR_DAY_PLAN_A6_PL_VAL ,VAR_DAY_PLAN_A7_PL_VAL ,VAR_DAY_PLAN_A8_PL_VAL
					,VAR_DAY_PLAN_B1_PL_VAL ,VAR_DAY_PLAN_B2_PL_VAL ,VAR_DAY_PLAN_B3_PL_VAL ,VAR_DAY_PLAN_B4_PL_VAL
					,VAR_DAY_PLAN_B5_PL_VAL ,VAR_DAY_PLAN_B6_PL_VAL ,VAR_DAY_PLAN_B7_PL_VAL ,VAR_DAY_PLAN_B8_PL_VAL						
					,VAR_DAY_PLAN_PHASE_CNT
		FROM BMS_CRS_SIGOPER_DAY_PLAN_INFO A
			LEFT JOIN BMS_CRS_MST B ON B.CRS_ID = A.CRS_ID
		WHERE A.CRS_ID = PARAM_CRS_ID
		AND A.DAY_PL_NO = VAR_DAY_PLAN_NO
		-- AND A.ST_TM < TIME_FORMAT(PARAM_DATE_TIME, '%H:%i')
		AND DATE_ADD(A.ST_TM, INTERVAL A.OFFSET SECOND) <= TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S')	
		
		ORDER BY A.ST_HOUR DESC
		LIMIT 1;		
	END IF;
		
	
	-- 특정 시간에 초록불 현시번호 찾기
	SET VAR_START_PERIOD_TM = DATE_ADD(VAR_DAY_PLAN_ST_TM, INTERVAL VAR_DAY_PLAN_OFFSET SECOND);
	
    
	SET VAR_LOOP_CNT = 0;
	loop_day_plan:LOOP
		
		SET VAR_END_PERIOD_TM = DATE_ADD(VAR_START_PERIOD_TM, INTERVAL VAR_DAY_PLAN_PERIOD_LEN SECOND);
		
	
		-- 찾고자 하는 시간이 각 주기별 계획시간에 포함되는지 확인
		 IF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_START_PERIOD_TM, '%H:%i:%S') && TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') < TIME_FORMAT(VAR_END_PERIOD_TM, '%H:%i:%S')) THEN					
			
			-- 찾고자 하는 시간이 각 현시별 계획시간에 포함되는지 확인					
			SET VAR_START_TM = VAR_START_PERIOD_TM;			
			SET VAR_END_TM = DATE_ADD(VAR_START_PERIOD_TM, INTERVAL VAR_DAY_PLAN_A1_PL_VAL SECOND);
			
						
			-- RING A
			SET VAR_LOOP_IDX = 1;
			WHILE(VAR_LOOP_IDX <= VAR_DAY_PLAN_PHASE_CNT) DO
			
				IF(VAR_LOOP_IDX = 1) THEN
					SET VAR_START_TM = VAR_START_PERIOD_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A1_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 2) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A2_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 3) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A3_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 4) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A4_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 5) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A5_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 6) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A6_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 7) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A7_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 8) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_A8_PL_VAL SECOND);	
				END IF;							
				
				-- 찾고자 하는 시간이 각 현시별 계획시간에 포함되는지 확인
				IF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_START_TM, '%H:%i:%S') && TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') < TIME_FORMAT(VAR_END_TM, '%H:%i:%S')) THEN			
					SET VAR_PHASE_NO_A = VAR_LOOP_IDX; -- 현재 진행 중인 A현시 번호
					
					IF(VAR_LOOP_IDX > PARAM_PHASE_NUM) THEN
						SET VAR_LOOP_IDX = VAR_DAY_PLAN_PHASE_CNT; -- for break;					
					END IF;			
				END IF;													
				
				
				IF(PARAM_PHASE_NUM = VAR_LOOP_IDX) THEN														
					-- 이번 주기에서 이미 끝난 현시인 경우
					IF( TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_END_TM, '%H:%i:%S') ) THEN
						SET VAR_START_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_PERIOD_LEN SECOND); -- 다음주기에서 실행 될 시간
						-- 남은시간 계산
						SET VAR_DIFF_SEC_A = TIME_TO_SEC(TIMEDIFF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S'), TIME_FORMAT(VAR_START_TM, '%H:%i:%S'))); 						
					ELSEIF(PARAM_PHASE_NUM = VAR_PHASE_NO_A) THEN -- 현재 진행 중인 현시인 경우
						SET VAR_DIFF_SEC_A = TIME_TO_SEC(TIMEDIFF(TIME_FORMAT(VAR_END_TM, '%H:%i:%S'), TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S'))); 																		
					ELSE -- 현재 진행 중인 현시가 아닌 경우
						SET VAR_DIFF_SEC_A = TIME_TO_SEC(TIMEDIFF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S'), TIME_FORMAT(VAR_START_TM, '%H:%i:%S'))); 																							
					
					END IF;								
					
					IF( (VAR_PHASE_NO_A != 0) && (VAR_PHASE_NO_A <= PARAM_PHASE_NUM) ) THEN
						SET VAR_LOOP_IDX = VAR_DAY_PLAN_PHASE_CNT; -- for break;
					END IF;										
				END IF;
				
				SET VAR_LOOP_IDX = VAR_LOOP_IDX+1;

			END WHILE;
			
			
			-- RING B
			SET VAR_LOOP_IDX = 1;
			WHILE(VAR_LOOP_IDX <= VAR_DAY_PLAN_PHASE_CNT) DO
			
				IF(VAR_LOOP_IDX = 1) THEN
					SET VAR_START_TM = VAR_START_PERIOD_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B1_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 2) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B2_PL_VAL SECOND);
				ELSEIF(VAR_LOOP_IDX = 3) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B3_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 4) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B4_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 5) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B5_PL_VAL SECOND);					
				ELSEIF(VAR_LOOP_IDX = 6) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B6_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 7) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B7_PL_VAL SECOND);	
				ELSEIF(VAR_LOOP_IDX = 8) THEN
					SET VAR_START_TM = VAR_END_TM;
					SET VAR_END_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_B8_PL_VAL SECOND);	
				END IF;							
				
				-- 찾고자 하는 시간이 각 현시별 계획시간에 포함되는지 확인				
				IF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_START_TM, '%H:%i:%S') && TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') < TIME_FORMAT(VAR_END_TM, '%H:%i:%S')) THEN			
					SET VAR_PHASE_NO_B = VAR_LOOP_IDX; -- 현재 진행 중인 B현시 번호
					
					IF(VAR_LOOP_IDX > PARAM_PHASE_NUM) THEN
						SET VAR_LOOP_IDX = VAR_DAY_PLAN_PHASE_CNT; -- for break;					
					END IF;			
				END IF;													
				
				
				IF(PARAM_PHASE_NUM = VAR_LOOP_IDX) THEN														
					-- 이번 주기에서 이미 끝난 현시인 경우
					IF( TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S') >= TIME_FORMAT(VAR_END_TM, '%H:%i:%S') ) THEN
						SET VAR_START_TM = DATE_ADD(VAR_START_TM, INTERVAL VAR_DAY_PLAN_PERIOD_LEN SECOND); -- 다음주기에서 실행 될 시간
						-- 남은시간 계산
						SET VAR_DIFF_SEC_B = TIME_TO_SEC(TIMEDIFF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S'), TIME_FORMAT(VAR_START_TM, '%H:%i:%S')));						
					ELSEIF(PARAM_PHASE_NUM = VAR_PHASE_NO_B) THEN -- 현재 진행 중인 현시인 경우
						-- 남은시간 계산
						SET VAR_DIFF_SEC_B = TIME_TO_SEC(TIMEDIFF(TIME_FORMAT(VAR_END_TM, '%H:%i:%S'), TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S')));											
					ELSE -- 현재 진행 중인 현시가 아닌 경우
						SET VAR_DIFF_SEC_B = TIME_TO_SEC(TIMEDIFF(TIME_FORMAT(PARAM_DATE_TIME, '%H:%i:%S'), TIME_FORMAT(VAR_START_TM, '%H:%i:%S'))); 																																			
					END IF;
										
					
					IF( (VAR_PHASE_NO_B != 0) && (VAR_PHASE_NO_B <= PARAM_PHASE_NUM) ) THEN
						SET VAR_LOOP_IDX = VAR_DAY_PLAN_PHASE_CNT; -- for break;
					END IF;					
				END IF;
				
				SET VAR_LOOP_IDX = VAR_LOOP_IDX+1;													


			END WHILE;			
			
			
			LEAVE loop_day_plan;
			
		END IF;
	
	
		SET VAR_START_PERIOD_TM = VAR_END_PERIOD_TM;
		
		SET VAR_LOOP_CNT = VAR_LOOP_CNT+1;
				
		IF(VAR_LOOP_CNT >= 5000) THEN	-- 무한루프방어코드					
			LEAVE loop_day_plan;
		END IF;		
		
	
	END LOOP;
	
	
	
	IF(VAR_PHASE_NO_A <= VAR_PHASE_NO_B) THEN
		SET RT_PHASE_NO = VAR_PHASE_NO_A;
		SET RT_REMAIN_SEC = VAR_DIFF_SEC_A;
	ELSE
		SET RT_PHASE_NO = VAR_PHASE_NO_B;
		SET RT_REMAIN_SEC = VAR_DIFF_SEC_B;		
	END IF;
	
	
	RETURN RT_REMAIN_SEC;
    #RETURN 0; -- 모든 교차로 신호 통과

END $$
DELIMITER ;;
